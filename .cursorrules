# MacbookSetup Project - Cursor Rules

## üéØ Core Development Philosophy
**Minimal Complexity Principle**: Always seek the least amount of code and complexity to achieve the goal.

## üìã Change Implementation Methodology

### 1. **Step-by-Step Validation Protocol**
- Make ONE small change at a time
- Run `zsh -n setup.sh` and `zsh -n verify_setup.sh` after each change
- Test execution with safe commands before proceeding
- Never make multiple unrelated changes in one step

### 2. **Pattern Reuse Strategy**
- ALWAYS look for existing patterns before creating new ones
- Reuse tree structure patterns from `generate_completion_files`
- Maintain consistency between `setup.sh` and `verify_setup.sh`
- Extend existing functions rather than creating new ones

### 3. **Testing Pipeline (Required Before Commit)**
```bash
# Required checks in this exact order:
1. zsh -n setup.sh && zsh -n verify_setup.sh
2. ./verify_setup.sh > /dev/null  # execution test
3. pre-commit run --all-files
4. git add . && git commit -m "descriptive message"
5. git push origin main
```

### 4. **Visual Consistency Rules**
- Use tree structure (`‚îú‚îÄ‚îÄ`, `‚îî‚îÄ‚îÄ`) for hierarchical output
- Maintain color coding: `$GREEN` for success, `$YELLOW` for warnings, `$BLUE` for info
- Group related operations under section headers: `=== Section Name ===`
- Keep consistent indentation patterns across both scripts

## üîß Code Modification Guidelines

### **Output Formatting Standards**
```bash
# Section headers
echo -e "\n=== Section Name ==="

# Tree items
printf "‚îú‚îÄ‚îÄ %bOperation%b description\n" "$BLUE" "$NC"
printf "‚îî‚îÄ‚îÄ %b[SUCCESS]%b Operation completed\n" "$GREEN" "$NC"

# Nested items
printf "‚îÇ   ‚îî‚îÄ‚îÄ %b[SUCCESS]%b Sub-operation ready\n" "$GREEN" "$NC"
printf "    ‚îî‚îÄ‚îÄ %b[SUCCESS]%b Deeply nested item\n" "$GREEN" "$NC"
```

### **Error Handling Preservation**
- Never remove existing error handling while making cosmetic changes
- Preserve all `|| return 1` and `|| exit 1` patterns
- Maintain graceful degradation for CI environments
- Keep warning messages for non-critical failures

### **Function Modification Rules**
- Prefer modifying output statements over changing function logic
- Use `printf` over `echo` for colored output with variables
- Replace `log_info` with section headers only for major groupings
- Keep `log_error` and `log_warning` for actual error conditions

## üìù Commit Message Standards

### **Format**: `<type>: <description> - <details>`

**Types**: `feat`, `fix`, `refactor`, `style`, `docs`, `test`, `chore`

**Example**:
```
feat: add tree structure to setup.sh output for consistency
- Apply hierarchical tree output to match verify_setup.sh visual style
- Group operations under sections: Installing Packages, Language Environments
- Use minimal code changes, reusing existing tree patterns
- Maintain clean visual flow throughout setup process
```

## üîß Shell Completion Update Requirement

### **Mandatory Completion Check**
When modifying any shell script (*.sh files) OR reorganizing project structure, you MUST check if shell completion needs updates:

1. **Check completion file**: `support/completions/_mcp_manager` for mcp_manager.sh changes
2. **Verify commands match**: Ensure completion options match actual commands
3. **Test completion**: Verify tab completion works for new/modified commands
4. **Update if needed**: Add new commands, options, or server IDs to completion
5. **Validate symlinks**: Check that ~/.zsh/completions/ symlinks point to correct locations

### **Files to Check**:
- `support/completions/_mcp_manager` - Completion for mcp_manager.sh
- `~/.zsh/completions/_mcp_manager` - User's completion symlink (if exists)
- Any other completion files in the project

### **CRITICAL: New MCP Server Addition Protocol**
When adding new MCP servers (like docker, slack, etc.), you MUST update shell completion:

1. **Update server list in completion**: Add new server_id to completion options
2. **Test tab completion**: Verify `./mcp_manager.sh test <TAB>` shows new server
3. **Update all command contexts**: test, setup, config, inspect commands should all recognize new server
4. **Validate completion works**: Test in clean shell: `autoload -U compinit && compinit`

**Example**: After adding "docker" server, completion should show:
```bash
./mcp_manager.sh test <TAB>  # Should show: github circleci filesystem docker
./mcp_manager.sh setup <TAB> # Should show: github circleci filesystem docker
```

### **Testing Protocol**:
```bash
# 1. Verify completion file exists and is readable
test -r support/completions/_mcp_manager && echo "‚úÖ Completion file readable" || echo "‚ùå File missing/unreadable"

# 2. Check symlink validity (if user has completion installed)
if [[ -L ~/.zsh/completions/_mcp_manager ]]; then
  test -r ~/.zsh/completions/_mcp_manager && echo "‚úÖ Symlink valid" || echo "‚ùå Broken symlink - needs update"
fi

# 3. Test completion functionality in clean shell
autoload -U compinit && compinit
./mcp_manager.sh <TAB><TAB>  # Should show available commands
```

### **File Relocation Protocol**
When moving completion files:
- ‚úÖ **Update all references** in documentation and setup scripts
- ‚úÖ **Check for existing user symlinks** in ~/.zsh/completions/
- ‚úÖ **Provide migration guidance** or automatic symlink updates
- ‚úÖ **Test completion works** after relocation

## üö´ Anti-Patterns to Avoid

### **Complexity Anti-Patterns**
- ‚ùå Creating new utility functions when existing ones work
- ‚ùå Adding configuration files for simple formatting changes
- ‚ùå Over-engineering solutions that could be simple printf statements
- ‚ùå Breaking working functionality for cosmetic improvements

### **Testing Anti-Patterns**
- ‚ùå Making multiple changes without intermediate testing
- ‚ùå Committing without running the full testing pipeline
- ‚ùå Assuming syntax check means execution will work
- ‚ùå Skipping pre-commit hooks "just this once"

### **Security Anti-Patterns**
- ‚ùå **NEVER commit `.envrc` files** - They contain sensitive environment variables
- ‚ùå Committing any file with real API tokens, passwords, or secrets
- ‚ùå Using real credentials in example files (use placeholders like "your-token-here")
- ‚ùå Ignoring GitHub push protection warnings about detected secrets

## üé® Project-Specific Patterns

### **Shell Script Consistency**
- Both `setup.sh` and `verify_setup.sh` should have matching visual output
- Use shared color variables: `$RED`, `$GREEN`, `$BLUE`, `$YELLOW`, `$NC`
- Extract version numbers using the shared `extract_version()` function
- Handle missing files gracefully with warnings, not errors

### **CI/Local Environment Handling**
- Always check `[[ "${CI:-false}" == "true" ]]` for CI-specific behavior
- Use `SKIP_ORBSTACK=true` for testing without Docker dependencies
- Provide graceful fallbacks for missing dependencies in CI

### **Zsh Compatibility**
- Use `for item in "${array[@]}"` instead of bash-style `${!array[@]}`
- Test all changes with `zsh -n` syntax checking
- Ensure compatibility with both zsh and bash environments

## üõ†Ô∏è Tool Integration Patterns (Added from Node.js/nvm experience)

### **Tool Classification and Handling**
- **Standard CLI Tools**: rbenv, pyenv, terraform ‚Üí Direct command line access
- **Sourced Tools**: nvm ‚Üí Require shell sourcing for initialization
- **GUI Applications**: Warp, iTerm2 ‚Üí Configuration via plist manipulation
- **Container Tools**: Docker, OrbStack ‚Üí Environment-dependent availability

### **Language Environment Standards**
```bash
# Template for adding new language environments:
setup_<language>_environment() {
  printf "‚îú‚îÄ‚îÄ %b<Language> Environment%b\n" "$BLUE" "$NC"

  # 1. Validate tool availability (with proper sourcing if needed)
  # 2. Determine latest version using tool-specific method
  # 3. Check if version already installed (tool-specific detection)
  # 4. Background installation with progress spinner
  # 5. Set default/global version
  # 6. Optional: Update package manager
  # 7. Success confirmation
}
```

### **Verification Complexity Handling**
- **Standard Tools**: Use `check_command "$tool"` and `"$tool" --version`
- **Sourced Tools**: Create special case blocks with proper initialization
- **Version Extraction**: Add tool-specific patterns to `extract_version()` function
- **Environment Graceful Degradation**: Distinguish between missing vs unavailable in CI

### **Shell Integration Rules**
- Tools requiring sourcing (like nvm) need:
  - Initialization in setup functions: `source "$(brew --prefix)/opt/tool/tool.sh"`
  - Special verification logic: Custom detection blocks in verify_setup.sh
  - Shell config addition: Proper PATH and sourcing in .zshrc
  - Completion handling: Both shell integration AND completion files

### **Error Handling for Special Cases**
- Use tool-specific error detection rather than generic patterns
- Provide informative error messages about tool requirements
- Maintain CI compatibility with appropriate warnings vs errors
- Always test both "tool not installed" and "tool installed but not working" scenarios

### **Consistency Enforcement Rules**
- Language environments must follow identical tree structure patterns
- All background installations must use `show_progress()` with proper spinner
- Version extraction must use shared `extract_version()` function
- Verification logic must handle tool-specific requirements while maintaining output consistency

## üîó MCP Server Integration Patterns (Added from GitHub/CircleCI experience)

### **MCP Server Addition Protocol**
When adding new MCP servers to the project, follow this exact pattern:

```bash
# 1. Add server to AVAILABLE_SERVERS array in mcp_manager.sh
AVAILABLE_SERVERS=("github" "circleci" "new-server")

# 2. Add Docker image mapping in get_docker_image()
get_docker_image() {
  case "$1" in
    "github") echo "mcp/github-mcp-server:latest" ;;
    "circleci") echo "local/mcp-server-circleci:latest" ;;
    "new-server") echo "vendor/new-server:latest" ;;
    *) return 1 ;;
  esac
}

# 3. Add environment variables in get_expected_env_vars()
get_expected_env_vars() {
  case "$1" in
    "new-server")
      echo "NEW_SERVER_TOKEN NEW_SERVER_API_KEY NEW_SERVER_BASE_URL"
      ;;
  esac
}

# 4. Add placeholder mapping in get_env_placeholder()
get_env_placeholder() {
  case "$1" in
    "NEW_SERVER_TOKEN") echo "your_new_server_token_here" ;;
    "NEW_SERVER_API_KEY") echo "your_api_key_here" ;;
    "NEW_SERVER_BASE_URL") echo "https://api.newserver.com" ;;
  esac
}
```

### **Configuration Generation Standards**
- **ALWAYS use --env-file approach**: Never inline environment variables in JSON
- **Use absolute paths**: `--env-file /Users/gfichtner/MacbookSetup/.env`
- **Generate .env_example**: Never overwrite existing `.env` files
- **Include all available servers**: Use `get_available_servers()` not just working ones
- **Maintain JSON structure consistency**: Both Cursor and Claude Desktop formats

### **Environment File Safety Rules**
- ‚ùå **NEVER generate or overwrite .env files directly**
- ‚úÖ **ALWAYS generate .env_example with placeholders**
- ‚úÖ **Read tokens from .env file, not environment variables**
- ‚úÖ **Validate against placeholders**: Detect "your_token_here" patterns
- ‚úÖ **Preserve existing .env**: Show "[INFO] Existing .env file found (keeping as-is)"

### **Token Detection and Validation**
```bash
# Template for server token validation:
server_has_real_tokens() {
  local server="$1"
  local env_vars
  env_vars=$(get_expected_env_vars "$server")

  for var in $env_vars; do
    local value placeholder
    value=$(grep "^${var}=" .env 2>/dev/null | cut -d'=' -f2- | tr -d '"')
    placeholder=$(get_env_placeholder "$var")

    if [[ -z "$value" || "$value" == "$placeholder" ]]; then
      return 1
    fi
  done
  return 0
}
```

### **Container Environment Testing**
- **Test variables inside containers**: Use `docker run --env-file .env image sh -c "echo \$VAR"`
- **Validate environment visibility**: Ensure all expected variables are accessible
- **Handle mixed output gracefully**: Use `grep -o` to extract JSON from startup messages
- **Support different parse modes**: Handle both "json" and default parsing

### **Debug Output Prevention (CRITICAL)**
- ‚ùå **NEVER leave debug trace enabled**: Check for `set -x`, `functrace`, etc.
- ‚ùå **NEVER output variable assignments**: Avoid `container_value=`, `image=` patterns
- ‚úÖ **Use structured output**: Tree format with proper status indicators
- ‚úÖ **Redirect debug info**: Send debugging to stderr or suppress entirely
- ‚úÖ **Test JSON validity**: Always validate with `jq` before committing

### **Health Check Architecture**
- **Basic Protocol Tests**: Always work in CI (no authentication required)
- **Advanced Functionality Tests**: Only when real tokens detected
- **Graceful Degradation**: Warn about missing tokens, don't fail
- **Container Environment Verification**: Test actual Docker variable visibility
- **Mixed Output Handling**: Support servers with startup messages before JSON

### **Testing Requirements for New Servers**
When adding MCP servers, update `spec/mcp_manager_spec.sh`:

```bash
# 1. Update expected_servers in has_expected_servers()
local expected_servers="github circleci new-server"

# 2. Add environment variable tests
The output should include "NEW_SERVER_TOKEN"
The output should include "NEW_SERVER_API_KEY"

# 3. Add placeholder tests
The output should include "your_new_server_token_here"

# 4. Add Docker image tests
The output should include "vendor/new-server:latest"
```

### **JSON Structure Consistency**
- **Cursor Format**: Direct server mapping `{ "server": { "command": "docker", "args": [...] } }`
- **Claude Desktop Format**: Nested under mcpServers `{ "mcpServers": { "server": {...} } }`
- **Args Array Standard**: `["run", "--rm", "-i", "--env-file", "path", "image"]`
- **No Inline Environment Variables**: Configuration should be environment-agnostic

### **Error Handling for MCP Servers**
- **Missing Docker**: Graceful fallback, generate configs anyway
- **Missing Tokens**: Warning messages, not errors
- **Container Failures**: Detailed error output with full Docker response
- **JSON Parsing Errors**: Strip non-JSON content before parsing
- **File Permission Issues**: Clear error messages about config file locations

### **Shell Completion Extension**
When adding new MCP servers, update `_mcp_manager`:
```bash
# Add server names to completion
case $line[1] in
  test|health|config-write)
    _arguments '*:servers:(github circleci new-server)'
    ;;
esac
```

## üìñ Documentation Maintenance Requirements

### **README.md Update Mandate**
When making significant changes to the project, you MUST update the README.md file to reflect:

**Required Updates For:**
- **New features or tools**: Add to appropriate sections, update examples
- **Script behavior changes**: Update testing strategy, CI behavior descriptions
- **Error handling improvements**: Update troubleshooting section
- **Configuration changes**: Update MCP server documentation, environment setup
- **Testing methodology changes**: Update CI testing strategy section
- **Output format changes**: Update examples and expected behavior

**Documentation Standards:**
- ‚úÖ **Update examples** to reflect actual current behavior
- ‚úÖ **Maintain consistency** between code behavior and documentation
- ‚úÖ **Add new troubleshooting entries** for newly discovered issues
- ‚úÖ **Update version numbers** and tool lists when dependencies change
- ‚úÖ **Validate all links** and commands in documentation still work

**Process:**
1. Make code changes
2. Test functionality
3. Update README.md accordingly
4. Commit both code AND documentation changes together

**‚ùå Anti-Pattern**: Never commit significant functionality changes without corresponding README updates

## üß™ Test-Driven Development (TDD) & Behavior-Driven Development (BDD) Principles

### **TDD Methodology (Red-Green-Refactor)**
**MANDATORY**: All new features MUST follow TDD cycle:

1. **üî¥ RED**: Write failing tests first
2. **üü¢ GREEN**: Write minimal code to make tests pass
3. **üîµ REFACTOR**: Improve code while keeping tests green

## üéØ **Generalized MCP Server Addition Test Framework**

### **üìã MCP Server Addition Protocol (Based on Docker Experience)**

When adding ANY new MCP server, follow this exact TDD-based protocol:

#### **üî¥ Phase 1: RED - Comprehensive Test Writing (Before ANY Implementation)**

**1.1 Registry Integration Tests**
```bash
# Add to spec/mcp_manager_spec.sh
Describe '<server_name> server integration'
  It 'includes <server_name> server in available servers list'
    When run zsh "$PWD/mcp_manager.sh" list
    The status should be success
    The output should include "<server_name>"
  End

  It 'supports <server_type> server type parsing'
    When run zsh "$PWD/mcp_manager.sh" parse <server_name> server_type
    The status should be success
    The output should equal "<server_type>"
  End
End
```

**1.2 Configuration Generation Tests**
```bash
# Test both Cursor and Claude Desktop configurations
It 'generates <server_name> configuration for Cursor'
  zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
  When run jq '.<server_name>' "$HOME/.cursor/mcp.json"
  The status should be success
  The output should include "<server_name>"
  The output should include "<expected_image>"
End

It 'generates <server_name> configuration for Claude Desktop'
  zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
  When run jq '.mcpServers.<server_name>' "$HOME/Library/Application Support/Claude/claude_desktop_config.json"
  The status should be success
  The output should include "<server_name>"
End
```

**1.3 Environment Variable Tests**
```bash
# Test environment variable generation and placeholders
It 'includes <server_name> environment variables in .env_example'
  zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
  When run grep "<ENV_VAR_1>\|<ENV_VAR_2>" "$PWD/.env_example"
  The status should be success
  The output should include "<ENV_VAR_1>"
  The output should include "<ENV_VAR_2>"
End

It '<server_name> environment variables include correct placeholders'
  zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
  When run grep "<ENV_VAR_1>\|<ENV_VAR_2>" "$PWD/.env_example"
  The status should be success
  The output should include "<expected_placeholder_1>"
  The output should include "<expected_placeholder_2>"
End
```

**1.4 Server Type-Specific Configuration Tests**
```bash
# For api_based servers:
It '<server_name> server uses standard --env-file approach'

# For mount_based servers:
It '<server_name> server uses mount-based configuration'

# For privileged servers:
It '<server_name> server uses privileged configuration with special access'
  # Test for Docker socket, networks, volumes, etc.

# For standalone servers:
It '<server_name> server requires no external dependencies'
```

**1.5 Individual Server Testing**
```bash
It '<server_name> server can be tested individually'
  When run zsh "$PWD/mcp_manager.sh" test <server_name>
  The status should be success
  The output should include "<Server Display Name>"
End
```

**1.6 Integration Testing**
```bash
It '<server_name> integrates with existing servers without conflicts'
  When run zsh "$PWD/mcp_manager.sh" test
  The status should be success
  The output should include "<server_name>"
  The output should include "github"  # Existing server still works
End
```

#### **üü¢ Phase 2: GREEN - Minimal Implementation (Make Tests Pass)**

**2.1 Registry Entry** (Always first step)
```yaml
# Add to mcp_server_registry.yml
<server_name>:
  name: "<Display Name>"
  server_type: "<api_based|mount_based|privileged|standalone>"
  description: "<Description>"
  category: "<category>"
  source:
    type: registry
    image: "<image_url>"
  environment_variables:  # If applicable
    - "<ENV_VAR_1>"
    - "<ENV_VAR_2>"
  # Additional type-specific configuration as needed
```

**2.2 Environment Variable Placeholders** (If new variables)
```bash
# Add to get_env_placeholder() function in mcp_manager.sh
"<ENV_VAR_1>")
  echo "<specific_placeholder_value>"
  ;;
"<ENV_VAR_2>")
  echo "<specific_placeholder_value>"
  ;;
```

**2.3 Server Type Extension** (If new server type needed)
```bash
# Extend all case statements that handle server_type:
# - Configuration generation (both Cursor and Claude)
# - Advanced functionality testing
# - Token detection logic
# - Preview generation

"<new_server_type>")
  <type_specific_handling>
  ;;
```

**2.4 Function Ordering Verification**
```bash
# CRITICAL: Ensure all helper functions are defined BEFORE use
# Check function call order:
1. Helper functions (get_*, server_*, etc.)
2. Test functions (test_*_advanced_functionality)
3. Configuration functions (generate_*, write_*)
4. Main command interface
```

#### **üîµ Phase 3: REFACTOR - Optimization & Documentation**

**3.1 Shell Completion Validation**
```bash
# Verify completion works automatically
awk '/^  [a-z].*:$/ { gsub(/:/, ""); gsub(/^  /, ""); print }' mcp_server_registry.yml
# Should include new server

# Test completion manually
./mcp_manager.sh test <TAB>  # Should show new server
```

**3.2 Documentation Updates**
- Update README.md with new server capabilities
- Add troubleshooting entries for server-specific issues
- Update examples and use cases

**3.3 Integration Verification**
```bash
# Full integration test suite
./mcp_manager.sh test                    # All servers work
./mcp_manager.sh config-write            # All configs generate
./mcp_manager.sh inspect                 # Inspector integration
```

### **üèóÔ∏è Server Type Classification Quick Reference**

**api_based**: GitHub, CircleCI, Linear, Slack
- Uses `--env-file` for API tokens
- Standard Docker configuration
- Token validation in advanced tests

**mount_based**: Filesystem, Local Development Tools
- Uses `--mount` for directory access
- Container path arguments
- File system operation tests

**privileged**: Docker, Kubernetes, System Tools
- Requires `--privileged` or special volumes (Docker socket)
- Network access requirements
- System-level validation tests

**standalone**: Inspector, Utilities, Converters
- No external dependencies
- No authentication required
- Self-contained functionality tests

### **‚ö†Ô∏è Common Pitfalls to Avoid (Learned from Docker Experience)**

1. **Function Ordering**: Always define helper functions BEFORE they're called
2. **Missing Test Categories**: Every server needs basic + advanced + integration tests
3. **Hardcoded Patterns**: Use server_type dispatch, never hardcode server names
4. **Configuration Gaps**: Test BOTH Cursor AND Claude Desktop configs
5. **Shell Completion**: Verify tab completion works after addition
6. **Environment Variables**: Always test placeholder generation
7. **Interactive Commands**: Use non-interactive flags (`-f`, `--yes`, `cat >`)
8. **Documentation Sync**: Update README.md with every functional change

### **‚úÖ Definition of Done for MCP Server Addition**

A new MCP server is complete when:
- [ ] All tests pass (8+ tests minimum covering all aspects)
- [ ] Configuration generated for both Cursor and Claude Desktop
- [ ] Environment variables have specific placeholders (not generic)
- [ ] Shell completion includes new server
- [ ] Integration with existing servers verified
- [ ] Documentation updated
- [ ] Function ordering verified (no "command not found" errors)
- [ ] Server type classification working correctly
- [ ] Manual testing completed with real server functionality

### **üìã Copy-Paste Template for New MCP Server Addition**

```bash
# üî¥ RED: Add these tests to spec/mcp_manager_spec.sh FIRST
Describe '[SERVER_NAME] server integration'
  It 'includes [SERVER_NAME] server in available servers list'
    When run zsh "$PWD/mcp_manager.sh" list
    The status should be success
    The output should include "[SERVER_NAME]"
  End

  It 'generates [SERVER_NAME] configuration for Cursor'
    zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
    When run jq '.[SERVER_NAME]' "$HOME/.cursor/mcp.json"
    The status should be success
    The output should include "[SERVER_NAME]"
    The output should include "[EXPECTED_IMAGE]"
  End

  It 'generates [SERVER_NAME] configuration for Claude Desktop'
    zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
    When run jq '.mcpServers.[SERVER_NAME]' "$HOME/Library/Application Support/Claude/claude_desktop_config.json"
    The status should be success
    The output should include "[SERVER_NAME]"
  End

  It 'includes [SERVER_NAME] environment variables in .env_example'
    zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
    When run grep "[ENV_VAR_1]\\|[ENV_VAR_2]" "$PWD/.env_example"
    The status should be success
    The output should include "[ENV_VAR_1]"
    The output should include "[ENV_VAR_2]"
  End

  It '[SERVER_NAME] environment variables include correct placeholders'
    zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
    When run grep "[ENV_VAR_1]\\|[ENV_VAR_2]" "$PWD/.env_example"
    The status should be success
    The output should include "[EXPECTED_PLACEHOLDER_1]"
    The output should include "[EXPECTED_PLACEHOLDER_2]"
  End

  It '[SERVER_NAME] server uses [SERVER_TYPE] configuration'
    zsh "$PWD/mcp_manager.sh" config-write > /dev/null 2>&1
    When run jq '.[SERVER_NAME].args[]' "$HOME/.cursor/mcp.json"
    The status should be success
    # Add server-type specific assertions here
  End

  It '[SERVER_NAME] server can be tested individually'
    When run zsh "$PWD/mcp_manager.sh" test [SERVER_NAME]
    The status should be success
    The output should include "[DISPLAY_NAME]"
  End

  It '[SERVER_NAME] server supports [SERVER_TYPE] server type'
    When run zsh "$PWD/mcp_manager.sh" parse [SERVER_NAME] server_type
    The status should be success
    The output should equal "[SERVER_TYPE]"
  End
End

# üü¢ GREEN: Run tests (should fail), then implement minimal code to pass
# 1. Add registry entry
# 2. Add environment variable placeholders (if needed)
# 3. Extend server type handling (if new type)
# 4. Verify function ordering

# üîµ REFACTOR: Optimize, document, validate integration
```

**Usage Instructions:**
1. Replace `[SERVER_NAME]` with actual server ID (e.g., `slack`, `linear`)
2. Replace `[DISPLAY_NAME]` with human-readable name (e.g., `Slack MCP Server`)
3. Replace `[SERVER_TYPE]` with classification (e.g., `api_based`, `privileged`)
4. Replace `[ENV_VAR_1]`, `[ENV_VAR_2]` with actual environment variables
5. Replace `[EXPECTED_PLACEHOLDER_1]` with specific placeholder values
6. Replace `[EXPECTED_IMAGE]` with Docker image URL

**Estimated Time per Server**: 15-30 minutes following this protocol vs. hours of debugging without it.

### **Test-First Development Rules**
- ‚ùå **NEVER write production code without a failing test first**
- ‚úÖ **ALWAYS start with the test that describes the expected behavior**
- ‚úÖ **Write the smallest possible test that fails**
- ‚úÖ **Only write enough production code to make the test pass**

### **ShellSpec Testing Standards**

#### **Test Organization**
```bash
# File structure for tests
spec/
‚îú‚îÄ‚îÄ spec_helper.sh          # Shared test utilities
‚îú‚îÄ‚îÄ mcp_manager_spec.sh     # Core MCP manager functionality
‚îú‚îÄ‚îÄ mcp_inspector_spec.sh   # New: Inspector functionality tests
‚îî‚îÄ‚îÄ integration_spec.sh     # End-to-end integration tests
```

#### **Test Writing Patterns**
```bash
# Use descriptive test names that explain behavior
Describe 'mcp_manager.sh inspect command'
  Describe 'when inspecting all servers'
    Context 'with no running containers'
      It 'should display "No MCP servers currently running"'
        When run ./mcp_manager.sh inspect
        The output should include "No MCP servers currently running"
        The status should be success
      End
    End

    Context 'with running containers'
      BeforeEach 'start_test_containers'
      AfterEach 'cleanup_test_containers'

      It 'should discover and list running servers'
        When run ./mcp_manager.sh inspect
        The output should include "Running MCP servers"
        The output should include "github"
        The status should be success
      End
    End
  End
End
```

#### **Test Categories by Scope**
1. **Unit Tests**: Test individual functions in isolation
2. **Integration Tests**: Test component interactions
3. **System Tests**: Test complete workflows end-to-end
4. **CI Tests**: Tests that run in CI environment (no Docker dependencies)

### **BDD Behavior Specification**

#### **Feature Definition Template**
```bash
# Every new feature starts with behavior specification
Describe 'MCP Inspector Feature'
  Describe 'inspect command basic functionality'
    It 'should show help when no arguments provided'
    It 'should discover running MCP server containers'
    It 'should validate environment variables'
    It 'should test server connectivity'
  End

  Describe 'inspect command advanced features'
    It 'should launch web UI on --ui flag'
    It 'should validate client configurations'
    It 'should run in CI-friendly mode'
    It 'should debug specific servers with --debug'
  End
End
```

#### **Given-When-Then Structure**
```bash
# Use Context/Setup for Given, When for actions, assertions for Then
Context 'Given a configured MCP server environment'
  Setup 'configure_test_environment'

  It 'When inspecting a specific server, Then should show detailed information'
    When run ./mcp_manager.sh inspect github
    The output should include "=== MCP Server Inspection: github ==="
    The output should include "[SERVER] GitHub MCP Server"
    The status should be success
  End
End
```

### **Test Implementation Workflow**

#### **For New Features (Inspector Example)**
```bash
# 1. Define the behavior first (RED)
It 'should provide UI access to MCP inspector'
  When run ./mcp_manager.sh inspect --ui
  The output should include "Inspector UI started"
  The output should include "http://localhost:6274"
  The status should be success
End

# 2. Run test (should fail)
shellspec spec/mcp_inspector_spec.sh

# 3. Implement minimal code to pass (GREEN)
# Add basic --ui handling to handle_inspect_command()

# 4. Run test (should pass)
shellspec spec/mcp_inspector_spec.sh

# 5. Refactor and improve (REFACTOR)
# Enhance error handling, improve output format
```

#### **Test Environment Setup Standards**
```bash
# Use consistent test helper patterns
setup_test_environment() {
  export TEST_HOME="$PWD/test_home"
  export CI=false
  mkdir -p "$TEST_HOME/.cursor"
  mkdir -p "$TEST_HOME/Library/Application Support/Claude"
}

cleanup_test_environment() {
  rm -rf "$TEST_HOME"
  docker container prune -f 2>/dev/null || true
}

mock_docker_commands() {
  # Create mock functions for Docker in test environment
  docker() {
    case "$1" in
      "ps") echo "CONTAINER ID   IMAGE                     NAMES"
            echo "123abc         mcp/github:latest        test-github" ;;
      "images") echo "mcp/github   latest   123   2 hours ago   100MB" ;;
    esac
  }
}
```

### **Test Coverage Requirements**

#### **Mandatory Test Coverage**
- ‚úÖ **All new commands must have tests**
- ‚úÖ **All error conditions must be tested**
- ‚úÖ **Both CI and local environments must be tested**
- ‚úÖ **Edge cases and error handling must be covered**

#### **Test Scenarios Matrix**
```bash
# Every new feature needs tests for:
#
# Environment Matrix:
# - Local development (Docker available)
# - CI environment (CI=true, limited Docker)
# - Missing dependencies (no Docker, no tools)
#
# Input Matrix:
# - Valid inputs
# - Invalid inputs
# - Missing inputs
# - Edge case inputs
#
# State Matrix:
# - Clean environment
# - Existing configurations
# - Partially configured state
# - Error states
```

### **Test Quality Standards**

#### **Test Readability Rules**
- ‚úÖ **Test names should read like documentation**
- ‚úÖ **Use descriptive Context and Describe blocks**
- ‚úÖ **One assertion per test when possible**
- ‚úÖ **Setup and teardown should be clear and isolated**

#### **Test Reliability Rules**
- ‚úÖ **Tests must be deterministic (no flaky tests)**
- ‚úÖ **Tests must be isolated (no dependencies between tests)**
- ‚úÖ **Tests must clean up after themselves**
- ‚úÖ **Tests must work in both CI and local environments**

### **Debugging Test Failures**

#### **Test Debugging Commands**
```bash
# Run specific test with verbose output
shellspec --format documentation spec/mcp_inspector_spec.sh

# Run single test case
shellspec --example "should discover running servers" spec/mcp_inspector_spec.sh

# Debug test with trace
shellspec --trace spec/mcp_inspector_spec.sh
```

#### **Common Test Failure Patterns**
- **Environment not isolated**: Tests affecting each other
- **Missing mocks**: Tests failing due to external dependencies
- **Race conditions**: Tests depending on timing
- **Path issues**: Tests not finding required files

### **Test-Driven Refactoring**

#### **Safe Refactoring Process**
1. ‚úÖ **Ensure all tests pass before refactoring**
2. ‚úÖ **Add tests for edge cases if missing**
3. ‚úÖ **Refactor incrementally**
4. ‚úÖ **Run tests after each small change**
5. ‚úÖ **Never skip tests because "it's just refactoring"**

### **TDD Anti-Patterns to Avoid**

#### **Development Anti-Patterns**
- ‚ùå **Writing production code before writing tests**
- ‚ùå **Writing tests that always pass (testing implementation, not behavior)**
- ‚ùå **Skipping the RED phase (not seeing tests fail first)**
- ‚ùå **Making multiple changes before running tests**

#### **Test Anti-Patterns**
- ‚ùå **Tests that depend on external services**
- ‚ùå **Tests that require manual setup**
- ‚ùå **Tests that test implementation details instead of behavior**
- ‚ùå **Giant tests that test multiple behaviors**

### **Integration with Existing Workflow**

#### **Updated Testing Pipeline**
```bash
# Enhanced testing pipeline for TDD workflow:
1. Write failing test first
2. zsh -n setup.sh && zsh -n verify_setup.sh  # Syntax check
3. shellspec spec/                            # Run all tests
4. Write minimal code to pass the test
5. shellspec spec/                            # Verify test passes
6. ./verify_setup.sh > /dev/null              # Integration test
7. pre-commit run --all-files                 # Code quality
8. MANDATORY CLEANUP PROTOCOL                 # See üßπ Mandatory Cleanup Protocol
9. git add . && git commit -m "descriptive message"
10. git push origin main
```

#### **CI Integration**
- ‚úÖ **All tests must pass in CI environment**
- ‚úÖ **Tests should gracefully handle CI limitations (no Docker)**
- ‚úÖ **Test results should be clearly reported**
- ‚úÖ **Failed tests should provide actionable error messages**

## üõ°Ô∏è Major Change Approval Protocol

### **When to Require User Confirmation**
Any change that falls into these categories **MUST** get explicit user approval before implementation:

#### **Structural Changes**
- ‚ùå **NEVER** reorganize directory structure without approval
- ‚ùå **NEVER** move files to new locations without confirmation
- ‚ùå **NEVER** delete files or directories (even temp files) without asking
- ‚ùå **NEVER** rename core scripts or configuration files

#### **Destructive Operations**
- ‚ùå **NEVER** use `rm`, `mv`, or `git rm` commands without explicit permission
- ‚ùå **ALWAYS** use `rm -f` or `rm -rf` to avoid interactive prompts when removal is approved
- ‚ùå **NEVER** remove or modify existing documentation sections
- ‚ùå **NEVER** change established workflows or testing pipelines
- ‚ùå **NEVER** modify configuration files that affect user environment

#### **Required Approval Process**
When a major change is needed:

1. **üõë STOP and present proposal**: "I recommend the following changes: [detailed list]"
2. **üìã Explain rationale**: Why these changes are needed and what benefits they provide
3. **‚ö†Ô∏è Highlight risks**: What could go wrong or what will be affected
4. **ü§î Wait for approval**: "Do you approve this approach?" or "Would you prefer a different solution?"
5. **‚úÖ Only proceed after explicit confirmation**: User says "yes," "proceed," or "approved"

#### **Example Proposal Format**
```
## üìã PROPOSAL: Directory Restructure

**Problem**: Supporting files are cluttering the root directory

**Proposed Changes**:
- Create support/ directory structure
- Move Dockerfile.mcp-inspector ‚Üí support/docker/mcp-inspector/
- Move _mcp_manager ‚Üí support/completions/
- Remove outdated .envrc_example

**Benefits**: Cleaner root, better organization, scalable for future MCP servers

**Risks**: Need to update references in scripts, potential disruption

**Question**: Do you approve this directory restructure approach?
```

### **Minor Changes That Don't Need Approval**
- ‚úÖ Bug fixes in existing functionality
- ‚úÖ Code formatting and style improvements
- ‚úÖ Adding tests for existing features
- ‚úÖ Documentation clarifications and corrections
- ‚úÖ Performance optimizations that don't change behavior

### **When in Doubt**
- **Always err on the side of asking for permission**
- **Present proposals before implementation**
- **Respect the user's project ownership**
- **Remember: it's easier to get approval than to fix mistakes**

## üßπ Mandatory Cleanup Protocol

### **When Cleanup is Required**
Cleanup is **MANDATORY** at the end of every major development step, including:

#### **Major Development Milestones**
- ‚úÖ **Feature Implementation**: After adding new commands, functions, or capabilities
- ‚úÖ **Bug Fixes**: After resolving issues that touched multiple files
- ‚úÖ **Refactoring**: After code reorganization or optimization
- ‚úÖ **Testing**: After adding new test suites or major test changes
- ‚úÖ **Documentation**: After significant README or documentation updates
- ‚úÖ **Configuration Changes**: After modifying workflows, CI, or project structure

### **Mandatory Cleanup Checklist**

#### **üóÇÔ∏è File Organization**
- ‚úÖ **Remove temporary files**: Delete `*.tmp`, `test_home/`, build artifacts
- ‚úÖ **Organize supporting files**: Ensure proper placement in `support/` structure
- ‚úÖ **Check for outdated files**: Remove deprecated configurations or examples
- ‚úÖ **Validate file permissions**: Ensure executable files have correct permissions

#### **üìù Documentation Sync**
- ‚úÖ **Update README.md**: Reflect any new functionality or changed workflows
- ‚úÖ **Update help text**: Ensure `./mcp_manager.sh help` matches implementation
- ‚úÖ **Update completion files**: Ensure shell completion matches available commands
- ‚úÖ **Update .cursorrules**: Document new patterns or learned best practices

#### **üß™ Quality Assurance**
- ‚úÖ **Run full test suite**: `shellspec spec/` - all tests must pass
- ‚úÖ **Syntax validation**: `zsh -n setup.sh && zsh -n verify_setup.sh`
- ‚úÖ **Integration test**: `./verify_setup.sh > /dev/null` (expect success or known issues)
- ‚úÖ **Pre-commit checks**: `pre-commit run --all-files` - all checks must pass

#### **üîß Code Quality**
- ‚úÖ **Remove debug output**: No `set -x`, `echo "debug:"`, or variable assignments in output
- ‚úÖ **Update path references**: Ensure all file paths point to correct locations
- ‚úÖ **Validate configurations**: Test that generated configs work correctly
- ‚úÖ **Check for unused functions**: Remove or document any unused code
- ‚úÖ **CI output validation**: Ensure CI pipelines have clean output without shell initialization errors

#### **üì¶ Git Hygiene**
- ‚úÖ **Stage all changes**: `git add -A` (after verifying no sensitive files)
- ‚úÖ **Descriptive commit**: Use format `<type>: <description> - <details>`
- ‚úÖ **Push to remote**: `git push origin main` after successful commit
- ‚úÖ **Verify CI**: Ensure remote builds pass (if applicable)

### **Cleanup Enforcement Rules**

#### **üõë Mandatory Cleanup Process**
At the end of every major development step, you MUST:

1. **üìã Announce Cleanup**: "Beginning mandatory cleanup for [feature/fix/refactor]"
2. **üßπ Execute Checklist**: Work through entire cleanup checklist systematically
3. **‚úÖ Verify Results**: Confirm all checklist items completed successfully
4. **üìù Document Status**: Report cleanup completion and any remaining items
5. **üöÄ Final Commit**: Only proceed after cleanup is 100% complete

#### **‚ùå No Exceptions**
- **Never skip cleanup** because "it's just a small change"
- **Never defer cleanup** to "next time" or "later"
- **Never commit** without completing the full cleanup checklist
- **Never push** without verifying all tests pass

## üö´ Interactive Command Anti-Patterns

### **CRITICAL: Always Use Non-Interactive Flags**
When using file operations in `run_terminal_cmd`, **ALWAYS** use non-interactive flags to prevent hanging on confirmations:

#### **Required Non-Interactive Patterns**
```bash
# ‚úÖ CORRECT - Non-interactive file operations
cp -f source destination     # Force overwrite without asking
mv source destination         # Move (usually non-interactive by default)
rm -f file                    # Force delete without asking
rm -rf directory              # Force recursive delete without asking
git add -A                    # Add all changes without interaction

# ‚ùå NEVER USE - Interactive commands that will hang
cp source destination         # Will ask "overwrite?" and hang
rm file                       # Will ask confirmation for protected files
rm -r directory              # Will ask before removing directory
```

#### **Shell Command Safety Rules**
- ‚úÖ **ALWAYS use `-f` flag** for `cp`, `rm` operations
- ‚úÖ **Test commands locally first** if unsure about interactivity
- ‚úÖ **Use `|| true`** for commands that might fail safely
- ‚ùå **NEVER assume commands are non-interactive** without verification
- ‚ùå **NEVER use interactive shells** (`zsh -i`, `bash -i`) in automation

#### **Common Interactive Traps to Avoid**
```bash
# These WILL hang and must be avoided:
cp .env_example .env                    # ‚ùå Asks overwrite confirmation
rm important_file                       # ‚ùå Asks confirmation for write-protected
mv file existing_file                   # ‚ùå Asks overwrite confirmation
git reset --hard                        # ‚ùå May ask confirmation in some setups
npm install                             # ‚ùå May ask for audit fix confirmations

# Use these safe alternatives instead:
cat source > destination               # ‚úÖ Shell redirection - completely non-interactive
cp -f .env_example .env                 # ‚úÖ Forces overwrite (but may still prompt on some systems)
rm -f important_file                    # ‚úÖ Forces deletion
mv file existing_file 2>/dev/null || true  # ‚úÖ Suppress errors if needed
git reset --hard HEAD                   # ‚úÖ More specific, less likely to prompt
npm install --yes                       # ‚úÖ Auto-confirm prompts
```

#### **Emergency Recovery Protocol**
If a command hangs due to interactive prompt:
1. **Recognize the pattern**: Command stops responding, cursor shows waiting
2. **Document the fix**: Note what flag was missing (`-f`, `--yes`, etc.)
3. **Update this rule**: Add the specific case to prevent recurrence
4. **Use force flags**: Always prefer automation over interaction

#### **üîÑ Cleanup Failure Recovery**
If cleanup reveals issues:

1. **üõë Stop development**: Do not proceed with new features
2. **üîß Fix issues**: Address any test failures or problems discovered
3. **üßπ Re-run cleanup**: Complete the full checklist again
4. **‚úÖ Verify success**: Ensure all issues are resolved
5. **üìù Document lessons**: Update .cursorrules with new patterns if needed

### **Cleanup Templates**

#### **Standard Cleanup Announcement**
```
## üßπ **Mandatory Cleanup: [Feature Name]**

### **Development Completed**
- ‚úÖ [List major changes made]
- ‚úÖ [Key functionality added/modified]

### **Cleanup Checklist**
- [ ] Remove temporary files
- [ ] Organize supporting files
- [ ] Update documentation
- [ ] Run full test suite
- [ ] Validate syntax and integration
- [ ] Check code quality
- [ ] Commit and push changes

### **Status**: [IN PROGRESS/COMPLETED]
```

#### **Cleanup Completion Report**
```
## ‚úÖ **Cleanup Complete: [Feature Name]**

### **Files Organized**
- ‚úÖ Temporary files removed: [list]
- ‚úÖ Supporting files organized: [moved files]
- ‚úÖ Outdated files removed: [list]

### **Quality Verification**
- ‚úÖ Tests passing: [X/X]
- ‚úÖ Syntax validation: PASS
- ‚úÖ Integration test: PASS
- ‚úÖ Pre-commit checks: PASS

### **Documentation Updated**
- ‚úÖ README.md: [changes made]
- ‚úÖ Help text: [updated sections]
- ‚úÖ Completion files: [new commands added]

### **Ready for Next Development Phase** üöÄ
```

## ü§ñ CI Environment Standards

### **Clean Output Requirements**
- ‚úÖ **No shell initialization errors**: Suppress `.zshrc` loading errors in CI with `2>/dev/null || true`
- ‚úÖ **No debug variable assignments**: Filter out `container_value=`, `server_count=`, etc.
- ‚úÖ **No command not found errors**: Handle missing tools gracefully in CI environments
- ‚úÖ **Structured output from line 1**: Ensure first line starts with section headers (`===`)

### **CI-Specific Error Handling**
- ‚úÖ **Shell setup errors**: Suppress plugin/completion failures that don't affect functionality
- ‚úÖ **Missing tool warnings**: Distinguish between critical failures and CI environment limitations
- ‚úÖ **Container unavailability**: Graceful degradation when Docker/OrbStack not available
- ‚úÖ **Test environment isolation**: Ensure CI tests don't depend on local development setup

### **CI Output Validation Tests**
- ‚úÖ **Add `spec/ci_output_spec.sh`**: Dedicated tests for clean CI output
- ‚úÖ **Test shell initialization**: Verify no stray error messages appear
- ‚úÖ **Test debug output filtering**: Ensure all debug variables are filtered
- ‚úÖ **Test structured output**: Verify consistent formatting across environments

## üîÑ Continuous Improvement
- Document successful patterns in this file
- Update rules based on what works in practice
- Keep the "minimal complexity" principle as the north star
- Review and refine these rules after major changes
- **Always maintain README.md alongside code changes**
- **Continuously improve test coverage and quality**
- **Refactor tests alongside production code**
