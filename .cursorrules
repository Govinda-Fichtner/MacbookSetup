# MacbookSetup Project - Cursor Rules

## üéØ Core Development Philosophy
**Minimal Complexity Principle**: Always seek the least amount of code and complexity to achieve the goal.

## üìã Change Implementation Methodology

### 1. **Step-by-Step Validation Protocol**
- Make ONE small change at a time
- Run `zsh -n setup.sh` and `zsh -n verify_setup.sh` after each change
- Test execution with safe commands before proceeding
- Never make multiple unrelated changes in one step

### 2. **Pattern Reuse Strategy**
- ALWAYS look for existing patterns before creating new ones
- Reuse tree structure patterns from `generate_completion_files`
- Maintain consistency between `setup.sh` and `verify_setup.sh`
- Extend existing functions rather than creating new ones

### 3. **Testing Pipeline (Required Before Commit)**
```bash
# Required checks in this exact order:
1. zsh -n setup.sh && zsh -n verify_setup.sh
2. ./verify_setup.sh > /dev/null  # execution test
3. pre-commit run --all-files
4. git add . && git commit -m "descriptive message"
5. git push origin main
```

### 4. **Visual Consistency Rules**
- Use tree structure (`‚îú‚îÄ‚îÄ`, `‚îî‚îÄ‚îÄ`) for hierarchical output
- Maintain color coding: `$GREEN` for success, `$YELLOW` for warnings, `$BLUE` for info
- Group related operations under section headers: `=== Section Name ===`
- Keep consistent indentation patterns across both scripts

## üîß Code Modification Guidelines

### **Output Formatting Standards**
```bash
# Section headers
echo -e "\n=== Section Name ==="

# Tree items
printf "‚îú‚îÄ‚îÄ %bOperation%b description\n" "$BLUE" "$NC"
printf "‚îî‚îÄ‚îÄ %b[SUCCESS]%b Operation completed\n" "$GREEN" "$NC"

# Nested items
printf "‚îÇ   ‚îî‚îÄ‚îÄ %b[SUCCESS]%b Sub-operation ready\n" "$GREEN" "$NC"
printf "    ‚îî‚îÄ‚îÄ %b[SUCCESS]%b Deeply nested item\n" "$GREEN" "$NC"
```

### **Error Handling Preservation**
- Never remove existing error handling while making cosmetic changes
- Preserve all `|| return 1` and `|| exit 1` patterns
- Maintain graceful degradation for CI environments
- Keep warning messages for non-critical failures

### **Function Modification Rules**
- Prefer modifying output statements over changing function logic
- Use `printf` over `echo` for colored output with variables
- Replace `log_info` with section headers only for major groupings
- Keep `log_error` and `log_warning` for actual error conditions

## üìù Commit Message Standards

### **Format**: `<type>: <description> - <details>`

**Types**: `feat`, `fix`, `refactor`, `style`, `docs`, `test`, `chore`

**Example**:
```
feat: add tree structure to setup.sh output for consistency
- Apply hierarchical tree output to match verify_setup.sh visual style
- Group operations under sections: Installing Packages, Language Environments
- Use minimal code changes, reusing existing tree patterns
- Maintain clean visual flow throughout setup process
```

## üö´ Anti-Patterns to Avoid

### **Complexity Anti-Patterns**
- ‚ùå Creating new utility functions when existing ones work
- ‚ùå Adding configuration files for simple formatting changes
- ‚ùå Over-engineering solutions that could be simple printf statements
- ‚ùå Breaking working functionality for cosmetic improvements

### **Testing Anti-Patterns**
- ‚ùå Making multiple changes without intermediate testing
- ‚ùå Committing without running the full testing pipeline
- ‚ùå Assuming syntax check means execution will work
- ‚ùå Skipping pre-commit hooks "just this once"

### **Security Anti-Patterns**
- ‚ùå **NEVER commit `.envrc` files** - They contain sensitive environment variables
- ‚ùå Committing any file with real API tokens, passwords, or secrets
- ‚ùå Using real credentials in example files (use placeholders like "your-token-here")
- ‚ùå Ignoring GitHub push protection warnings about detected secrets

## üé® Project-Specific Patterns

### **Shell Script Consistency**
- Both `setup.sh` and `verify_setup.sh` should have matching visual output
- Use shared color variables: `$RED`, `$GREEN`, `$BLUE`, `$YELLOW`, `$NC`
- Extract version numbers using the shared `extract_version()` function
- Handle missing files gracefully with warnings, not errors

### **CI/Local Environment Handling**
- Always check `[[ "${CI:-false}" == "true" ]]` for CI-specific behavior
- Use `SKIP_ORBSTACK=true` for testing without Docker dependencies
- Provide graceful fallbacks for missing dependencies in CI

### **Zsh Compatibility**
- Use `for item in "${array[@]}"` instead of bash-style `${!array[@]}`
- Test all changes with `zsh -n` syntax checking
- Ensure compatibility with both zsh and bash environments

## üõ†Ô∏è Tool Integration Patterns (Added from Node.js/nvm experience)

### **Tool Classification and Handling**
- **Standard CLI Tools**: rbenv, pyenv, terraform ‚Üí Direct command line access
- **Sourced Tools**: nvm ‚Üí Require shell sourcing for initialization
- **GUI Applications**: Warp, iTerm2 ‚Üí Configuration via plist manipulation
- **Container Tools**: Docker, OrbStack ‚Üí Environment-dependent availability

### **Language Environment Standards**
```bash
# Template for adding new language environments:
setup_<language>_environment() {
  printf "‚îú‚îÄ‚îÄ %b<Language> Environment%b\n" "$BLUE" "$NC"

  # 1. Validate tool availability (with proper sourcing if needed)
  # 2. Determine latest version using tool-specific method
  # 3. Check if version already installed (tool-specific detection)
  # 4. Background installation with progress spinner
  # 5. Set default/global version
  # 6. Optional: Update package manager
  # 7. Success confirmation
}
```

### **Verification Complexity Handling**
- **Standard Tools**: Use `check_command "$tool"` and `"$tool" --version`
- **Sourced Tools**: Create special case blocks with proper initialization
- **Version Extraction**: Add tool-specific patterns to `extract_version()` function
- **Environment Graceful Degradation**: Distinguish between missing vs unavailable in CI

### **Shell Integration Rules**
- Tools requiring sourcing (like nvm) need:
  - Initialization in setup functions: `source "$(brew --prefix)/opt/tool/tool.sh"`
  - Special verification logic: Custom detection blocks in verify_setup.sh
  - Shell config addition: Proper PATH and sourcing in .zshrc
  - Completion handling: Both shell integration AND completion files

### **Error Handling for Special Cases**
- Use tool-specific error detection rather than generic patterns
- Provide informative error messages about tool requirements
- Maintain CI compatibility with appropriate warnings vs errors
- Always test both "tool not installed" and "tool installed but not working" scenarios

### **Consistency Enforcement Rules**
- Language environments must follow identical tree structure patterns
- All background installations must use `show_progress()` with proper spinner
- Version extraction must use shared `extract_version()` function
- Verification logic must handle tool-specific requirements while maintaining output consistency

## üîÑ Continuous Improvement
- Document successful patterns in this file
- Update rules based on what works in practice
- Keep the "minimal complexity" principle as the north star
- Review and refine these rules after major changes
