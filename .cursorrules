# MacbookSetup Project - Cursor Rules

## 🎯 Core Development Philosophy
**Minimal Complexity Principle**: Always seek the least amount of code and complexity to achieve the goal.

## 📋 Change Implementation Methodology

### 1. **Step-by-Step Validation Protocol**
- Make ONE small change at a time
- Run `zsh -n setup.sh` and `zsh -n verify_setup.sh` after each change
- Test execution with safe commands before proceeding
- Never make multiple unrelated changes in one step

### 2. **Pattern Reuse Strategy**
- ALWAYS look for existing patterns before creating new ones
- Reuse tree structure patterns from `generate_completion_files`
- Maintain consistency between `setup.sh` and `verify_setup.sh`
- Extend existing functions rather than creating new ones

### 3. **Testing Pipeline (Required Before Commit)**
```bash
# Required checks in this exact order:
1. zsh -n setup.sh && zsh -n verify_setup.sh
2. ./verify_setup.sh > /dev/null  # execution test
3. pre-commit run --all-files
4. git add . && git commit -m "descriptive message"
5. git push origin main
```

### 4. **Visual Consistency Rules**
- Use tree structure (`├──`, `└──`) for hierarchical output
- Maintain color coding: `$GREEN` for success, `$YELLOW` for warnings, `$BLUE` for info
- Group related operations under section headers: `=== Section Name ===`
- Keep consistent indentation patterns across both scripts

## 🔧 Code Modification Guidelines

### **Output Formatting Standards**
```bash
# Section headers
echo -e "\n=== Section Name ==="

# Tree items
printf "├── %bOperation%b description\n" "$BLUE" "$NC"
printf "└── %b[SUCCESS]%b Operation completed\n" "$GREEN" "$NC"

# Nested items
printf "│   └── %b[SUCCESS]%b Sub-operation ready\n" "$GREEN" "$NC"
printf "    └── %b[SUCCESS]%b Deeply nested item\n" "$GREEN" "$NC"
```

### **Error Handling Preservation**
- Never remove existing error handling while making cosmetic changes
- Preserve all `|| return 1` and `|| exit 1` patterns
- Maintain graceful degradation for CI environments
- Keep warning messages for non-critical failures

### **Function Modification Rules**
- Prefer modifying output statements over changing function logic
- Use `printf` over `echo` for colored output with variables
- Replace `log_info` with section headers only for major groupings
- Keep `log_error` and `log_warning` for actual error conditions

## 📝 Commit Message Standards

### **Format**: `<type>: <description> - <details>`

**Types**: `feat`, `fix`, `refactor`, `style`, `docs`, `test`, `chore`

**Example**:
```
feat: add tree structure to setup.sh output for consistency
- Apply hierarchical tree output to match verify_setup.sh visual style
- Group operations under sections: Installing Packages, Language Environments
- Use minimal code changes, reusing existing tree patterns
- Maintain clean visual flow throughout setup process
```

## 🔧 Shell Completion Update Requirement

### **Mandatory Completion Check**
When modifying any shell script (*.sh files), you MUST check if shell completion needs updates:

1. **Check completion file**: `_mcp_manager` for mcp_manager.sh changes
2. **Verify commands match**: Ensure completion options match actual commands
3. **Test completion**: Verify tab completion works for new/modified commands
4. **Update if needed**: Add new commands, options, or server IDs to completion

### **Files to Check**:
- `_mcp_manager` - Completion for mcp_manager.sh
- Any other completion files in the project

### **Testing**:
```bash
# Source completion and test
source _mcp_manager
./mcp_manager.sh <TAB><TAB>  # Should show available commands
```

## 🚫 Anti-Patterns to Avoid

### **Complexity Anti-Patterns**
- ❌ Creating new utility functions when existing ones work
- ❌ Adding configuration files for simple formatting changes
- ❌ Over-engineering solutions that could be simple printf statements
- ❌ Breaking working functionality for cosmetic improvements

### **Testing Anti-Patterns**
- ❌ Making multiple changes without intermediate testing
- ❌ Committing without running the full testing pipeline
- ❌ Assuming syntax check means execution will work
- ❌ Skipping pre-commit hooks "just this once"

### **Security Anti-Patterns**
- ❌ **NEVER commit `.envrc` files** - They contain sensitive environment variables
- ❌ Committing any file with real API tokens, passwords, or secrets
- ❌ Using real credentials in example files (use placeholders like "your-token-here")
- ❌ Ignoring GitHub push protection warnings about detected secrets

## 🎨 Project-Specific Patterns

### **Shell Script Consistency**
- Both `setup.sh` and `verify_setup.sh` should have matching visual output
- Use shared color variables: `$RED`, `$GREEN`, `$BLUE`, `$YELLOW`, `$NC`
- Extract version numbers using the shared `extract_version()` function
- Handle missing files gracefully with warnings, not errors

### **CI/Local Environment Handling**
- Always check `[[ "${CI:-false}" == "true" ]]` for CI-specific behavior
- Use `SKIP_ORBSTACK=true` for testing without Docker dependencies
- Provide graceful fallbacks for missing dependencies in CI

### **Zsh Compatibility**
- Use `for item in "${array[@]}"` instead of bash-style `${!array[@]}`
- Test all changes with `zsh -n` syntax checking
- Ensure compatibility with both zsh and bash environments

## 🛠️ Tool Integration Patterns (Added from Node.js/nvm experience)

### **Tool Classification and Handling**
- **Standard CLI Tools**: rbenv, pyenv, terraform → Direct command line access
- **Sourced Tools**: nvm → Require shell sourcing for initialization
- **GUI Applications**: Warp, iTerm2 → Configuration via plist manipulation
- **Container Tools**: Docker, OrbStack → Environment-dependent availability

### **Language Environment Standards**
```bash
# Template for adding new language environments:
setup_<language>_environment() {
  printf "├── %b<Language> Environment%b\n" "$BLUE" "$NC"

  # 1. Validate tool availability (with proper sourcing if needed)
  # 2. Determine latest version using tool-specific method
  # 3. Check if version already installed (tool-specific detection)
  # 4. Background installation with progress spinner
  # 5. Set default/global version
  # 6. Optional: Update package manager
  # 7. Success confirmation
}
```

### **Verification Complexity Handling**
- **Standard Tools**: Use `check_command "$tool"` and `"$tool" --version`
- **Sourced Tools**: Create special case blocks with proper initialization
- **Version Extraction**: Add tool-specific patterns to `extract_version()` function
- **Environment Graceful Degradation**: Distinguish between missing vs unavailable in CI

### **Shell Integration Rules**
- Tools requiring sourcing (like nvm) need:
  - Initialization in setup functions: `source "$(brew --prefix)/opt/tool/tool.sh"`
  - Special verification logic: Custom detection blocks in verify_setup.sh
  - Shell config addition: Proper PATH and sourcing in .zshrc
  - Completion handling: Both shell integration AND completion files

### **Error Handling for Special Cases**
- Use tool-specific error detection rather than generic patterns
- Provide informative error messages about tool requirements
- Maintain CI compatibility with appropriate warnings vs errors
- Always test both "tool not installed" and "tool installed but not working" scenarios

### **Consistency Enforcement Rules**
- Language environments must follow identical tree structure patterns
- All background installations must use `show_progress()` with proper spinner
- Version extraction must use shared `extract_version()` function
- Verification logic must handle tool-specific requirements while maintaining output consistency

## 🔗 MCP Server Integration Patterns (Added from GitHub/CircleCI experience)

### **MCP Server Addition Protocol**
When adding new MCP servers to the project, follow this exact pattern:

```bash
# 1. Add server to AVAILABLE_SERVERS array in mcp_manager.sh
AVAILABLE_SERVERS=("github" "circleci" "new-server")

# 2. Add Docker image mapping in get_docker_image()
get_docker_image() {
  case "$1" in
    "github") echo "mcp/github-mcp-server:latest" ;;
    "circleci") echo "local/mcp-server-circleci:latest" ;;
    "new-server") echo "vendor/new-server:latest" ;;
    *) return 1 ;;
  esac
}

# 3. Add environment variables in get_expected_env_vars()
get_expected_env_vars() {
  case "$1" in
    "new-server")
      echo "NEW_SERVER_TOKEN NEW_SERVER_API_KEY NEW_SERVER_BASE_URL"
      ;;
  esac
}

# 4. Add placeholder mapping in get_env_placeholder()
get_env_placeholder() {
  case "$1" in
    "NEW_SERVER_TOKEN") echo "your_new_server_token_here" ;;
    "NEW_SERVER_API_KEY") echo "your_api_key_here" ;;
    "NEW_SERVER_BASE_URL") echo "https://api.newserver.com" ;;
  esac
}
```

### **Configuration Generation Standards**
- **ALWAYS use --env-file approach**: Never inline environment variables in JSON
- **Use absolute paths**: `--env-file /Users/gfichtner/MacbookSetup/.env`
- **Generate .env_example**: Never overwrite existing `.env` files
- **Include all available servers**: Use `get_available_servers()` not just working ones
- **Maintain JSON structure consistency**: Both Cursor and Claude Desktop formats

### **Environment File Safety Rules**
- ❌ **NEVER generate or overwrite .env files directly**
- ✅ **ALWAYS generate .env_example with placeholders**
- ✅ **Read tokens from .env file, not environment variables**
- ✅ **Validate against placeholders**: Detect "your_token_here" patterns
- ✅ **Preserve existing .env**: Show "[INFO] Existing .env file found (keeping as-is)"

### **Token Detection and Validation**
```bash
# Template for server token validation:
server_has_real_tokens() {
  local server="$1"
  local env_vars
  env_vars=$(get_expected_env_vars "$server")

  for var in $env_vars; do
    local value placeholder
    value=$(grep "^${var}=" .env 2>/dev/null | cut -d'=' -f2- | tr -d '"')
    placeholder=$(get_env_placeholder "$var")

    if [[ -z "$value" || "$value" == "$placeholder" ]]; then
      return 1
    fi
  done
  return 0
}
```

### **Container Environment Testing**
- **Test variables inside containers**: Use `docker run --env-file .env image sh -c "echo \$VAR"`
- **Validate environment visibility**: Ensure all expected variables are accessible
- **Handle mixed output gracefully**: Use `grep -o` to extract JSON from startup messages
- **Support different parse modes**: Handle both "json" and default parsing

### **Debug Output Prevention (CRITICAL)**
- ❌ **NEVER leave debug trace enabled**: Check for `set -x`, `functrace`, etc.
- ❌ **NEVER output variable assignments**: Avoid `container_value=`, `image=` patterns
- ✅ **Use structured output**: Tree format with proper status indicators
- ✅ **Redirect debug info**: Send debugging to stderr or suppress entirely
- ✅ **Test JSON validity**: Always validate with `jq` before committing

### **Health Check Architecture**
- **Basic Protocol Tests**: Always work in CI (no authentication required)
- **Advanced Functionality Tests**: Only when real tokens detected
- **Graceful Degradation**: Warn about missing tokens, don't fail
- **Container Environment Verification**: Test actual Docker variable visibility
- **Mixed Output Handling**: Support servers with startup messages before JSON

### **Testing Requirements for New Servers**
When adding MCP servers, update `spec/mcp_manager_spec.sh`:

```bash
# 1. Update expected_servers in has_expected_servers()
local expected_servers="github circleci new-server"

# 2. Add environment variable tests
The output should include "NEW_SERVER_TOKEN"
The output should include "NEW_SERVER_API_KEY"

# 3. Add placeholder tests
The output should include "your_new_server_token_here"

# 4. Add Docker image tests
The output should include "vendor/new-server:latest"
```

### **JSON Structure Consistency**
- **Cursor Format**: Direct server mapping `{ "server": { "command": "docker", "args": [...] } }`
- **Claude Desktop Format**: Nested under mcpServers `{ "mcpServers": { "server": {...} } }`
- **Args Array Standard**: `["run", "--rm", "-i", "--env-file", "path", "image"]`
- **No Inline Environment Variables**: Configuration should be environment-agnostic

### **Error Handling for MCP Servers**
- **Missing Docker**: Graceful fallback, generate configs anyway
- **Missing Tokens**: Warning messages, not errors
- **Container Failures**: Detailed error output with full Docker response
- **JSON Parsing Errors**: Strip non-JSON content before parsing
- **File Permission Issues**: Clear error messages about config file locations

### **Shell Completion Extension**
When adding new MCP servers, update `_mcp_manager`:
```bash
# Add server names to completion
case $line[1] in
  test|health|config-write)
    _arguments '*:servers:(github circleci new-server)'
    ;;
esac
```

## 🔄 Continuous Improvement
- Document successful patterns in this file
- Update rules based on what works in practice
- Keep the "minimal complexity" principle as the north star
- Review and refine these rules after major changes
