#!/bin/zsh
# shellcheck shell=bash

# Log formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
  echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
  echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
  echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
  echo -e "${RED}[ERROR]${NC} $1"
}

# Add debug logging to help diagnose issues
log_debug() {
  echo -e "[DEBUG] $1"
}

# Completion verification configuration
# Format: tool_name=(type source test_commands)
# type: zinit_plugin, builtin, or custom
# source: plugin name for zinit, path for builtin, or command for custom
# test_commands: space-separated list of commands to test completion
typeset -A completion_config
completion_config=(
  # Terraform uses zinit plugin
  ["terraform"]="zinit_plugin macunha1/zsh-terraform init plan apply destroy"
  
  # Git uses built-in zsh completion
  ["git"]="builtin _git checkout branch commit push pull"
  
  # rbenv uses custom completion setup
  ["rbenv"]="custom 'eval \"$(rbenv init -)\"' install local global"
  
  # pyenv uses custom completion setup
  ["pyenv"]="custom 'eval \"$(pyenv init -)\"' install local global"
  
  # direnv uses custom hook
  ["direnv"]="custom 'eval \"$(direnv hook zsh)\"' allow deny"
  
  # Packer uses built-in completion
  ["packer"]="builtin _packer build init validate"

  # Starship prompt
  ["starship"]="custom 'eval \"$(starship init zsh)\"' init configure preset"

  # Kubernetes tools
  ["kubectl"]="custom 'source <(kubectl completion zsh)' get describe apply delete"
  ["helm"]="custom 'source <(helm completion zsh)' install upgrade rollback list"
  ["kubectx"]="custom 'source <(kubectl completion zsh)' none"
)

# Function to test completion setup for a tool
test_completion() {
  local tool=$1
  local config=${completion_config[$tool]}
  
  if [[ -z "$config" ]]; then
    log_debug "No completion configuration found for $tool"
    return 0
  }
  
  # Parse configuration
  local type=${config%% *}
  local remaining=${config#* }
  local source=${remaining%% *}
  local test_commands=${remaining#* }
  
  printf "%-30s ... " "$tool completion"
  
  # Skip test if tool is not installed
  if ! command -v "$tool" >/dev/null 2>&1; then
    echo "⏭️  SKIPPED"
    log_info "$tool not installed, skipping completion test"
    return 0
  }
  
  case $type in
    "zinit_plugin")
      if ! zinit list 2>/dev/null | grep -q "$source"; then
        echo "❌ FAIL"
        log_error "$tool completion plugin ($source) not installed"
        return 1
      fi
      ;;
      
    "builtin")
      if ! type "$source" >/dev/null 2>&1; then
        echo "❌ FAIL"
        log_error "$tool built-in completion ($source) not available"
        return 1
      fi
      ;;
      
    "custom")
      # Try to evaluate the custom completion setup
      if ! eval "$source" >/dev/null 2>&1; then
        echo "❌ FAIL"
        log_error "$tool custom completion setup failed"
        return 1
      fi
      ;;
  esac
  
  # Test if completion functions work for the specified commands
  local all_commands_complete=true
  for cmd in $test_commands; do
    if ! test_command_completion "$tool" "$cmd"; then
      all_commands_complete=false
      log_warning "$tool completion for '$cmd' not working"
    fi
  done
  
  if $all_commands_complete; then
    echo "✅ PASS"
    log_success "$tool completion verified"
    return 0
  else
    echo "⚠️  PARTIAL"
    return 1
  fi
}

# Function to test completion for a specific command
test_command_completion() {
  local tool=$1
  local cmd=$2
  
  # Skip for 'none' test commands
  if [[ "$cmd" == "none" ]]; then
    return 0
  }
  
  # First check if the command exists
  if ! command -v "$tool" >/dev/null 2>&1; then
    log_debug "$tool command not found"
    return 1
  fi
  
  # Try to generate completions for the command
  # This is a basic test that just verifies the completion function exists
  if ! zsh -c "autoload -U compinit && compinit && _${tool}" >/dev/null 2>&1; then
    log_debug "Completion function for $tool not working"
    return 1
  fi
  
  return 0
}

[... rest of the file remains unchanged ...]
